/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-podofo.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : podofo
 #	author : miyako
 #	2020/12/11
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-podofo.h"

#pragma mark -

static void OnStartup() {
    
#ifdef PODOFO_HAVE_OPENSSL_1_1
    OPENSSL_init_crypto(0, NULL);
#else
    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();
    ERR_load_PEM_strings();
    ERR_load_ASN1_strings();
    ERR_load_EVP_strings();
#endif

}

static void OnExit() {
    
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
                case kInitPlugin :
                case kServerInitPlugin :
                    OnStartup();
                    break;
                    
                case kDeinitPlugin :
                case kServerDeinitPlugin :
                    OnExit();
                    break;
                
			// --- podofo form
            
            case 1 :
                podofo_get_form(params);
                break;
            case 2 :
                podofo_set_form(params);
                break;
            case 3 :
                podofo_sign_document(params);
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark convert

static void convert_to_platform_path(CUTF8String *path) {
#if VERSIONMAC
    if(path) {
        if(path->length()) {
            
            NSString *s = [[NSString alloc]initWithUTF8String:(const char *)path->c_str()];
            NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)s, kCFURLHFSPathStyle, false);
            if(u) {
                NSString *p = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
                [u release];
                *path = CUTF8String((const uint8_t *)[p UTF8String]);
            }
            [s release];
        }
    }
#endif
}

static double convert_to_pdf_unit(PA_ObjectRef obj, const wchar_t *key) {
    
    double value = 0.0;
    
    if(ob_is_defined(obj, key)) {
        value = ob_get_n(obj, key);
        CUTF8String unit;
        if(ob_get_s(obj, L"unit", &unit)) {
            if(unit.find((const uint8_t *)"mm") != CUTF8String::npos) {
                return 72.0 * value  / 25.4;
            }
            if(unit.find((const uint8_t *)"in") != CUTF8String::npos) {
                return 72.0 * value  ;
            }
        }
    }
    
    return value;
}

#pragma mark ob

static PA_Picture ob_get_p(PA_ObjectRef obj, const wchar_t *_key) {

    PA_Picture p = NULL;
    
    bool is_defined = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        is_defined = PA_HasObjectProperty(obj, &key);
        
        if(is_defined)
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            if(PA_GetVariableKind(v) == eVK_Picture)
            {
                p = PA_GetPictureVariable(v);
            }
        }
    }
    
    return p;
}

static bool ob_is_0(PA_ObjectRef obj, const wchar_t *_key) {
    
    bool is_null = false;
    
    if(obj)
    {
        CUTF16String ukey;
        json_wconv(_key, &ukey);
        PA_Unistring key = PA_CreateUnistring((PA_Unichar *)ukey.c_str());
        
        if(PA_HasObjectProperty(obj, &key))
        {
            PA_Variable v = PA_GetObjectProperty(obj, &key);
            is_null = (PA_GetVariableKind(v) == -1);
        }
    }
    
    return is_null;
}

static void ob_set_box(PA_ObjectRef obj, const wchar_t *_key, const PdfRect& rect) {
    
    if(obj) {
        PA_ObjectRef box = PA_CreateObject();

        ob_set_n(box, L"left"  , rect.GetLeft());
        ob_set_n(box, L"bottom", rect.GetBottom());
        ob_set_n(box, L"width" , rect.GetWidth());
        ob_set_n(box, L"height", rect.GetHeight());
        
        ob_set_o(obj, _key, box);
    }
}

#pragma mark param

static void get_param_path(PA_ObjectRef param,
                      const wchar_t *param_name,
                      CUTF8String *param_value) {
    
    param_value->clear();
    
    if((param) && (param_name)) {
        if(ob_is_defined(param, param_name)) {
            if(ob_get_s(param, param_name, param_value)) {
                convert_to_platform_path(param_value);
            }
        }
    }
}

static void get_param_string(PA_ObjectRef param,
                             const wchar_t *param_name,
                             CUTF8String *param_value) {
    
    param_value->clear();
    
    if((param) && (param_name)) {
        
        if(ob_is_defined(param, param_name)) {
            if(ob_get_s(param, param_name, param_value)) {
                
            }
        }
    }
}

static unsigned int get_param_integer(PA_ObjectRef param,
                                      const wchar_t *param_name) {
    
    unsigned int value = 0;
    
    if((param) && (param_name)) {
        
        if(ob_is_defined(param, param_name)) {
            int _value = ob_get_n(param, param_name);
            if( _value > 0) {
                value = _value;
            }
        }
    }
    
    return value;
}

#pragma mark -

#ifdef _WIN32
static void u8_to_u16(CUTF8String& u8, CUTF16String& u16) {
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }

}
#endif

static void collection_push(PA_CollectionRef c, PA_ObjectRef value) {
    
    if(value) {
        PA_Variable v = PA_CreateVariable(eVK_Object);
        PA_SetObjectVariable(&v, value);
        PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
        PA_ClearVariable(&v);
    }
}

static void get_picture_data(PA_Picture pdf_in, const char *format, C_BLOB& pdf) {
    
    if(pdf_in) {
        PA_ErrorCode err = eER_NoErr;
        PA_long32 idx = 0;
        while (err == eER_NoErr)
        {
            PA_Unistring type = PA_GetPictureData(pdf_in, ++idx, NULL);
            err = PA_GetLastError();
            if(err == eER_NoErr)
            {
                PA_long32 len;
                len = (uint32_t)(type.fLength * 4) + sizeof(uint8_t);
                std::vector<uint8_t> buf(len);
                len = PA_ConvertCharsetToCharset(
                                                 (char *)type.fString,
                                                 type.fLength * sizeof(PA_Unichar),
                                                 eVTC_UTF_16,
                                                 (char *)&buf[0],
                                                 len,
                                                 eVTC_UTF_8
                                                 );
                std::string uti((const char *)&buf[0], len);
                if(uti.find(format) != std::string::npos) {
                    PA_Handle h = PA_NewHandle(0);
                    err = eER_NoErr;
                    PA_GetPictureData(pdf_in, idx, h);
                    err = PA_GetLastError();
                    if(err == eER_NoErr)
                    {
                        pdf.setBytes((const uint8_t *)PA_LockHandle(h), PA_GetHandleSize(h));
                        PA_UnlockHandle(h);
                        break;
                    }
                }
            }
        }
    }
}

static FILE *ufopen(const char *filename, const char *mode) {
    
#ifdef _WIN32
    wchar_t    buf[_MAX_PATH];
    wchar_t    _wfmode[99];    //should be enough
    if(MultiByteToWideChar(CP_UTF8, 0, mode, -1, (LPWSTR)_wfmode, 99))
    {
        if(MultiByteToWideChar(CP_UTF8, 0, filename, -1, (LPWSTR)buf, _MAX_PATH))
        {
            return _wfopen((const wchar_t *)buf, (const wchar_t *)_wfmode);
        }
    }
    return  fopen(filename, mode);
#else
    return fopen(filename, mode);
#endif
}

static int pkey_password_cb(char *buf, int bufsize, int PODOFO_UNUSED_PARAM(rwflag), void *userdata) {
    
    const char *password = reinterpret_cast<const char *>(userdata);
    
    if (!password)
        return 0;
    
    int res = (int)strlen(password);
    
    if (res > bufsize)
        res = bufsize;
    
    memcpy(buf, password, res);
    
    return res;
}

static pdf_int32 get_signature_objects(PA_ObjectRef param, X509 **cert, EVP_PKEY **key, BIO **bio_cert, BIO**bio_key) {
    
    pdf_int32 min_signature_size = 0;
    
    if(param) {
        
        CUTF8String param_cert, param_cert_file;
        
        if(ob_is_defined(param, L"certFile")) {
            get_param_path(param, L"certFile" , &param_cert_file);
        }
        
        if(ob_is_defined(param, L"cert")) {
            ob_get_s(param, L"cert", &param_cert);
        }
        
        CUTF8String param_key, param_key_file;
        
        if(ob_is_defined(param, L"keyFile")) {
            get_param_path(param, L"keyFile" , &param_key_file);
        }
        
        if(ob_is_defined(param, L"key")) {
            ob_get_s(param, L"key", &param_key);
        }
        
        CUTF8String param_password;
        get_param_string(param, L"keyPassword", &param_password);
        
        if(param_cert_file.length()) {
            FILE *fp = NULL;
            fp = ufopen((const char *)param_cert_file.c_str(), "rb");
            if(fp) {
                *cert = PEM_read_X509(fp, NULL, NULL, NULL);
                if(fseeko(fp, 0, SEEK_END ) != -1)
                    min_signature_size += ftello(fp);
                else
                    min_signature_size += 3072;
                fclose(fp);
            }
        }else if(param_cert.length()) {
            *bio_cert = BIO_new_mem_buf((const void *)param_cert.c_str(), (int)param_cert.length());
            *cert = PEM_read_bio_X509(*bio_cert, NULL, NULL, NULL);
            min_signature_size += param_cert.length();
        }
        
        if(param_key_file.length()) {
            FILE *fp = NULL;
            fp = ufopen((const char *)param_key_file.c_str(), "rb");
            if(fp) {
                *key = PEM_read_PrivateKey(fp,
                                           NULL,
                                           pkey_password_cb, (char *)param_password.c_str());
                
                if(fseeko(fp, 0, SEEK_END) != -1)
                    min_signature_size += ftello(fp);
                else
                    min_signature_size += 1024;
                fclose(fp);
            }
            }else if(param_key.length()) {
            *bio_key = BIO_new_mem_buf((const void *)param_key.c_str(), (int)param_key.length());
            *key = PEM_read_bio_PrivateKey(*bio_key,
                                           NULL,
                                           pkey_password_cb, (char *)param_password.c_str());
            
            min_signature_size += param_key.length();
        }
    }
    
    return min_signature_size;
}

static PdfObject* find_existing_signature_field(PdfAcroForm* pAcroForm, const PdfString& name) {
    
    if( !pAcroForm )
        PODOFO_RAISE_ERROR( ePdfError_InvalidHandle );
    
    PdfObject* pFields = pAcroForm->GetObject()->GetDictionary().GetKey( PdfName( "Fields" ) );
    if( pFields )
    {
        if( pFields->GetDataType() == ePdfDataType_Reference )
            pFields = pAcroForm->GetDocument()->GetObjects()->GetObject( pFields->GetReference() );
        
        if( pFields && pFields->GetDataType() == ePdfDataType_Array )
        {
            PdfArray &rArray = pFields->GetArray();
            PdfArray::iterator it, end = rArray.end();
            for( it = rArray.begin(); it != end; it++ )
            {
                // require references in the Fields array
                if( it->GetDataType() == ePdfDataType_Reference )
                {
                    PdfObject *item = pAcroForm->GetDocument()->GetObjects()->GetObject( it->GetReference() );
                    
                    if( item && item->GetDictionary().HasKey( PdfName( "T" ) ) &&
                       item->GetDictionary().GetKey( PdfName( "T" ) )->GetString() == name )
                    {
                        // found a field with the same name
                        const PdfObject *pFT = item->GetDictionary().GetKey( PdfName( "FT" ) );
                        if( !pFT && item->GetDictionary().HasKey( PdfName( "Parent" ) ) )
                        {
                            const PdfObject *pTemp = item->GetIndirectKey( PdfName( "Parent" ) );
                            if( !pTemp )
                            {
                                PODOFO_RAISE_ERROR( ePdfError_InvalidDataType );
                            }
                            
                            pFT = pTemp->GetDictionary().GetKey( PdfName( "FT" ) );
                        }
                        
                        if( !pFT )
                        {
                            PODOFO_RAISE_ERROR( ePdfError_NoObject );
                        }
                        
                        const PdfName fieldType = pFT->GetName();
                        if( fieldType != PdfName( "Sig" ) )
                        {
                            std::string err = "Existing field '";
                            err += name.GetString();
                            err += "' isn't of a signature type, but '";
                            err += fieldType.GetName().c_str();
                            err += "' instead";
                            
                            PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidName, err.c_str() );
                        }
                        
                        return item;
                    }
                }
            }
        }
    }
    
    return NULL;
}

static void raise_podofo_error_with_opensslerror(const char *detail) {
    
    std::string err;
        
    if( err.empty() )
        err = "Unknown OpenSSL error";
    
    err = ": " + err;
    err = detail + err;
    
    PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, err.c_str() );
}

static void sign_with_signer(PdfSignOutputDevice &signer, X509 *cert, EVP_PKEY *pkey) {
    
    if( !cert )
        PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "cert == NULL" );
    if( !pkey )
        PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "pkey == NULL" );
    
    unsigned int uBufferLen = 65535;
    size_t len;
    char *pBuffer;
    
    while( static_cast<void>(pBuffer = reinterpret_cast<char *>( podofo_malloc( sizeof( char ) * uBufferLen) )), !pBuffer )
    {
        uBufferLen = uBufferLen / 2;
        if( !uBufferLen )
            break;
    }
    
    if( !pBuffer )
        PODOFO_RAISE_ERROR (ePdfError_OutOfMemory);
    
    int rc;
    BIO *mem = BIO_new( BIO_s_mem() );
    if( !mem )
    {
        podofo_free( pBuffer );
        raise_podofo_error_with_opensslerror( "Failed to create input BIO" );
    }
    
    unsigned int flags = PKCS7_DETACHED | PKCS7_BINARY;
    PKCS7 *pkcs7 = PKCS7_sign( cert, pkey, NULL, mem, flags );
    if( !pkcs7 )
    {
        BIO_free( mem );
        podofo_free( pBuffer );
        raise_podofo_error_with_opensslerror( "PKCS7_sign failed" );
    }
    
    while( static_cast<void>(len = signer.ReadForSignature( pBuffer, uBufferLen )), len > 0 )
    {
        rc = BIO_write( mem, pBuffer, (int)len);
        if( static_cast<unsigned int>( rc ) != len )
        {
            PKCS7_free( pkcs7 );
            BIO_free( mem );
            podofo_free( pBuffer );
            raise_podofo_error_with_opensslerror( "BIO_write failed" );
        }
    }
    
    podofo_free( pBuffer );
    
    if( PKCS7_final( pkcs7, mem, flags ) <= 0 )
    {
        PKCS7_free( pkcs7 );
        BIO_free( mem );
        raise_podofo_error_with_opensslerror( "PKCS7_final failed" );
    }
    
    bool success = false;
    BIO *out = BIO_new( BIO_s_mem() );
    if( !out )
    {
        PKCS7_free( pkcs7 );
        BIO_free( mem );
        raise_podofo_error_with_opensslerror( "Failed to create output BIO" );
    }
    
    char *outBuff = NULL;
    long outLen;
    
    i2d_PKCS7_bio( out, pkcs7 );
    
    outLen = BIO_get_mem_data( out, &outBuff );
    
    if( outLen > 0 && outBuff )
    {
        if( static_cast<size_t>( outLen ) > signer.GetSignatureSize() )
        {
            PKCS7_free( pkcs7 );
            BIO_free( out );
            BIO_free( mem );
            
            std::ostringstream oss;
            oss << "Requires at least " << outLen << " bytes for the signature, but reserved is only " << signer.GetSignatureSize() << " bytes";
            PODOFO_RAISE_ERROR_INFO( ePdfError_ValueOutOfRange, oss.str().c_str() );
        }
        
        PdfData signature( outBuff, outLen );
        signer.SetSignature( signature );
        success = true;
    }
    
    PKCS7_free( pkcs7 );
    BIO_free( out );
    BIO_free( mem );
    
    if( !success )
        raise_podofo_error_with_opensslerror( "Failed to get data from the output BIO" );
}

static PA_ObjectRef getObjectInCollection(PA_CollectionRef c, PA_long32 i) {
    
    PA_ObjectRef o = NULL;
    
    PA_Variable v = PA_GetCollectionElement(c, i);
    
    if(PA_GetVariableKind(v) == eVK_Object) {
        o = PA_GetObjectVariable(v);
    }
    
    PA_ClearVariable(&v);
    
    return o;
}

#pragma mark icon

static bool set_field_icon_for_state(PdfImage *image, PdfAnnotation *annotation,
                                     PdfPage *page, PdfRect *rect, PdfDocument *document,
                                     EPdfAnnotationAppearance state) {

    PdfRect imageRect(0.0, 0.0, image->GetWidth(), image->GetHeight());
    
    PdfXObject xObj(imageRect, document);
    annotation->SetAppearanceStream(&xObj);
    
    PdfPainter painter;
    painter.SetPage(&xObj);
    painter.DrawImage(0.0, 0.0, image, 1.0, 1.0 );
    painter.FinishPage();

    return true;
}

static bool set_field_icon(PdfButton *field, PA_ObjectRef fieldObj, PdfPage *page, PdfRect *rect, PdfDocument *document) {
    
    PdfAnnotation *annotation = field->GetWidgetAnnotation();
    
    /*
     do this to prevent the image from scaling to fit
     */
    
    PdfString textValue((const pdf_utf8 *)"");
    field->SetCaption(textValue);
    set_text_properties(annotation, fieldObj, "" /*textValue*/, document);
    
    if(ob_is_defined(fieldObj, L"icon")) {
        
        PdfImage image(document);
        
        PA_Picture icon_in = ob_get_p(fieldObj, L"icon");
        C_BLOB icon;
        get_picture_data(icon_in, "png", icon);
        if(!icon.getBytesLength()) {
            get_picture_data(icon_in, "jpg", icon);
        }
        
        if(icon.getBytesLength()) {
            image.LoadFromData((const unsigned char *)icon.getBytesPtr(), (pdf_long)icon.getBytesLength());
        }else{
            CUTF8String path;
            if(!icon.getBytesLength()) {
                get_param_path(fieldObj, L"icon", &path);
            }
            
            if(path.length()) {
#ifdef _WIN32
                CUTF16String w_param_in;
                u8_to_u16(path,  w_param_in );
                const wchar_t *inputfile = path .length() ? (const wchar_t *)w_param_in .c_str() : NULL;
#else
                const char *inputfile = path.length() ? (const char *)path.c_str() : NULL;
#endif
                try {
                    image.LoadFromFile(inputfile);
                }catch( PdfError & e )
                {
                    e.PrintErrorMsg();
                }
            }
        }
        set_field_icon_for_state(&image,
                                 annotation, page, rect, document,
                                 ePdfAnnotationAppearance_Down);
    }
    
}

#pragma mark field

static bool process_combobox(CUTF8String& type,
                             CUTF8String& fieldName,
                             std::map<CUTF8String,
                             PdfField>& fields,
                             PdfRect& rect,
                             PA_ObjectRef fieldObj,
                             PdfPage *page,
                             PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"comboBox") != CUTF8String::npos) {
        
        bool didUpdate = false;

		auto it = fields.find(fieldName);
        if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_PushButton) {
                try{
                    PdfComboBox listField(field);
                    PdfAnnotation *annotation = listField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&listField, fieldObj, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                PdfComboBox listField(page, rect, document);
                listField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&listField, fieldObj, document);
                
                didUpdate = true;
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
    }
    
    return didUpdate;
}

static bool process_listbox(CUTF8String& type,
                            CUTF8String& fieldName,
                            std::map<CUTF8String,
                            PdfField>& fields,
                            PdfRect& rect,
                            PA_ObjectRef fieldObj,
                            PdfPage *page,
                            PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"listBox") != CUTF8String::npos) {
        
        bool didUpdate = false;

		auto it = fields.find(fieldName);
        if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_PushButton) {
                try{
                    PdfListBox listField(field);
                    PdfAnnotation *annotation = listField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&listField, fieldObj, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                PdfListBox listField(page, rect, document);
                listField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&listField, fieldObj, document);
                
                didUpdate = true;
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
    }
    
    return didUpdate;
}

static bool process_radiobutton(CUTF8String& type,
                               CUTF8String& fieldName,
                               std::map<CUTF8String,
                               PdfField>& fields,
                               PdfRect& rect,
                               PA_ObjectRef fieldObj,
                               PdfPage *page,
                               PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"radioButton") != CUTF8String::npos) {
        
        bool didUpdate = false;
        
		auto it = fields.find(fieldName);
		if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_RadioButton) {
                try{
                    PdfButton radioButtonField(field);
                    PdfAnnotation *annotation = radioButtonField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&radioButtonField, fieldObj, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                //no constructor
                PdfPushButton radioButtonField(page, rect, document);
                radioButtonField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&radioButtonField, fieldObj, document);
                
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
        
    }
    
    return didUpdate;
}

static bool process_pushbutton(CUTF8String& type,
                               CUTF8String& fieldName,
                               std::map<CUTF8String,
                               PdfField>& fields,
                               PdfRect& rect,
                               PA_ObjectRef fieldObj,
                               PdfPage *page,
                               PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"pushButton") != CUTF8String::npos) {
        
        bool didUpdate = false;
        
		auto it = fields.find(fieldName);
		if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_PushButton) {
                try{
                    PdfPushButton pushButtonField(field);
                    PdfAnnotation *annotation = pushButtonField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&pushButtonField, fieldObj, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                PdfPushButton pushButtonField(page, rect, document);
                pushButtonField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&pushButtonField, fieldObj, document);

                didUpdate = true;
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
    }

    return didUpdate;
}

static bool process_checkbox(CUTF8String& type,
                             CUTF8String& fieldName,
                             std::map<CUTF8String,
                             PdfField>& fields,
                             PdfRect& rect,
                             PA_ObjectRef fieldObj,
                             PdfPage *page,
                             PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"checkBox") != CUTF8String::npos) {
        
        bool didUpdate = false;
        
		auto it = fields.find(fieldName);
		if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_CheckBox) {
                try{
                    PdfCheckBox checkboxField(field);
                    PdfAnnotation *annotation = checkboxField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&checkboxField, fieldObj, document);
                    set_field_icon(&checkboxField, fieldObj, page, &rect, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                PdfCheckBox checkboxField(page, rect, document);
                checkboxField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&checkboxField, fieldObj, document);
                set_field_icon(&checkboxField, fieldObj, page, &rect, document);
                
                didUpdate = true;
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
    }
    
    return didUpdate;
}

static bool process_textfield(CUTF8String& type,
                              CUTF8String& fieldName,
                              std::map<CUTF8String,
                              PdfField>& fields,
                              PdfRect& rect,
                              PA_ObjectRef fieldObj,
                              PdfPage *page,
                              PdfDocument *document) {
    
    bool didUpdate = false;
    
    if(type.find((const uint8_t *)"textField") != CUTF8String::npos) {

		auto it = fields.find(fieldName);
        if (it != end(fields)) {
            PdfField field = it->second;
            EPdfField fieldType = field.GetType();
            if(fieldType == ePdfField_TextField) {
                try{
                    PdfTextField textField(field);
                    PdfAnnotation *annotation = textField.GetWidgetAnnotation();
                    annotation->SetRect(rect);
                    set_properties(&textField, fieldObj, document);
                    
                    didUpdate = true;
                }catch(PdfError &e){
                    e.PrintErrorMsg();
                    
                }
            }
        }
        
        if(!didUpdate) {
            try{
                PdfTextField textField(page, rect, document);
                textField.SetFieldName(PdfString((const pdf_utf8 *)fieldName.c_str()));
                set_properties(&textField, fieldObj, document);
                
                didUpdate = true;
            }catch(PdfError &e){
                e.PrintErrorMsg();
                
            }
        }
    }

    return didUpdate;
}

#pragma mark annotation

static bool insert_link_annotation(PA_ObjectRef annotationObj, PdfPage *page, PdfRect *rect, PdfDocument *document) {
    
    bool didInsert = false;

    CUTF8String value;
    get_param_string(annotationObj, L"URI", &value);
    if(value.length()) {
        PdfAnnotation *annotation = page->CreateAnnotation(ePdfAnnotation_Link, *rect);
        PdfString textValue((const char *)value.c_str());//this must NOT be unicode!
        PdfAction action(ePdfAction_URI, document);
        action.SetURI(textValue);
        annotation->SetAction(action);
        annotation->SetRect(*rect);//need this!
                
        set_annotation_properties(annotation, annotationObj);
        
        didInsert = true;
    }
    
    return didInsert;
}

static bool insert_stamp_annotation(PA_ObjectRef annotationObj, PdfPage *page, PdfRect *rect, PdfDocument *document) {
    
    bool didInsert = false;
    
    if(ob_is_defined(annotationObj, L"icon")) {
        
        PdfImage image(document);
        
        PA_Picture icon_in = ob_get_p(annotationObj, L"icon");
        C_BLOB icon;
        get_picture_data(icon_in, "png", icon);
        if(!icon.getBytesLength()) {
            get_picture_data(icon_in, "jpg", icon);
        }
        
        if(icon.getBytesLength()) {
            image.LoadFromData((const unsigned char *)icon.getBytesPtr(), (pdf_long)icon.getBytesLength());
        }else{
            CUTF8String path;
            if(!icon.getBytesLength()) {
                get_param_path(annotationObj, L"icon", &path);
            }
            
            if(path.length()) {
#ifdef _WIN32
				CUTF16String w_param_in;
                u8_to_u16(path,  w_param_in );
                const wchar_t *inputfile = path .length() ? (const wchar_t *)w_param_in .c_str() : NULL;
#else
                const char *inputfile = path.length() ? (const char *)path.c_str() : NULL;
#endif
                try {
                    image.LoadFromFile(inputfile);
                }catch( PdfError & e )
                {
                    e.PrintErrorMsg();
                }
            }
        }
        
        /*
         const char **supportedTypes(PdfImage::GetSupportedFormats());
         
         std::vector<std::string> types;
         while (*supportedTypes) {
         types.push_back(*supportedTypes);
         *supportedTypes++;
         }
         */
        
        /* JPEG PNG TIFF(?) */
        
        PdfRect imageRect(0.0, 0.0, image.GetWidth(), image.GetHeight());
        
        PdfAnnotation *annotation = page->CreateAnnotation(ePdfAnnotation_Stamp, *rect);
        annotation->SetRect(*rect);//need this!
        
        PdfXObject xObj(imageRect, document);
        annotation->SetAppearanceStream(&xObj);
        
        PdfPainter painter;
        painter.SetPage(&xObj);
        painter.DrawImage(0.0, 0.0, &image, 1.0, 1.0 );
        painter.FinishPage();
        
        set_annotation_properties(annotation, annotationObj);
        
        didInsert = true;
    }
    
    return didInsert;
}

static bool insert_text_annotation(PA_ObjectRef annotationObj, PdfPage *page, PdfRect *rect, PdfDocument *document) {
    
    bool didInsert = false;
    
    CUTF8String value;
    get_param_string(annotationObj, L"value", &value);
    if(value.length()) {
        PdfAnnotation *annotation = page->CreateAnnotation(ePdfAnnotation_FreeText, *rect);
        PdfString textValue((const pdf_utf8 *)value.c_str());
        annotation->SetRect(*rect);//need this!
        annotation->SetContents(textValue);
        set_annotation_properties(annotation, annotationObj);
        set_text_properties(annotation, annotationObj,"" /*textValue*/, document);

        didInsert = true;
    }
    
    return didInsert;
}

static void insert_text(PA_ObjectRef pageObj, double pageHeight, PdfPage *page, PdfDocument *document) {
    
    PA_CollectionRef textCol = ob_get_c(pageObj, L"text");
    if(textCol) {
        for(PA_long32 t = 0; t < PA_GetCollectionLength(textCol);++t) {
            PA_ObjectRef textObj = getObjectInCollection(textCol, t);
            if(textObj) {
                
                CUTF8String textValue;
                if(ob_get_s(textObj, L"value", &textValue)) {
                    
                    //this is unicode string
                    PdfString utextValue(reinterpret_cast<const pdf_utf8 *>(textValue.c_str()));
                    
                    double x, y, width, height;
                    get_rect(textObj, pageHeight, &x, &y, &width, &height);
                    PdfRect rect(x, y, width, height);
                    
                    bool didDrawText = false;
                    
                    PdfPainter painter;
                    painter.SetPage(page);
                    
                    set_color(&painter, textObj);
                    
                    PdfFont *font = NULL;
                    
                    CUTF8String fontValue;
                    if(ob_get_s(textObj, L"font", &fontValue)) {
                        if(fontValue.length()) {
                            font = document->CreateFont((const char *)fontValue.c_str(), new PdfIdentityEncoding(0, 0xffff, true));
                        }
                    }
                        
                    if(!font) {
                        font = document->CreateFont((const char *)"Arial" , new PdfIdentityEncoding(0, 0xffff, true));
                    }
                    
                    if(font) {
                        painter.SetFont(font);
                        if(ob_is_defined(textObj, L"fontSize")) {
                            font->SetFontSize(ob_get_n(textObj, L"fontSize"));
                        }
                    }
                    
                    CUTF8String alignValue;
                    if(ob_get_s(textObj, L"halign", &alignValue)) {
                        EPdfAlignment halign = ePdfAlignment_Left;
                        if(alignValue.find((const uint8_t *)"right") != CUTF8String::npos) {
                            halign = ePdfAlignment_Right;
                        }else
                            if(alignValue.find((const uint8_t *)"center") != CUTF8String::npos) {
                                halign = ePdfAlignment_Center;
                            }
                        
                        if(ob_get_s(textObj, L"valign", &alignValue)) {
                            EPdfVerticalAlignment valign = ePdfVerticalAlignment_Top;
                            if(alignValue.find((const uint8_t *)"bottom") != CUTF8String::npos) {
                                valign = ePdfVerticalAlignment_Bottom;
                            }else
                                if(alignValue.find((const uint8_t *)"center") != CUTF8String::npos) {
                                    valign = ePdfVerticalAlignment_Center;
                                }
                            painter.DrawMultiLineText(PdfRect(x, y, width, height), utextValue,
                                                      halign, valign);
                            didDrawText = true;
                        }
                        
                        if(!didDrawText) {
                                                        
                            painter.DrawTextAligned(x, y, width, utextValue, halign);
                            didDrawText = true;
                        }
                    }
                    
                    if(!didDrawText) {
                        painter.DrawText(x, y, utextValue);
                    }
                    
                    painter.FinishPage();
                }
                
            }
            
        }
    }
    
}

static void insert_annotation(PA_ObjectRef pageObj, double pageHeight, PdfPage *page, PdfDocument *document) {
    
    PA_CollectionRef annotationCol = ob_get_c(pageObj, L"annotation");
    if(annotationCol) {
        for(PA_long32 a = 0; a < PA_GetCollectionLength(annotationCol);++a) {
            PA_ObjectRef annotationObj = getObjectInCollection(annotationCol, a);
            if(annotationObj) {
                CUTF8String type;
                if(ob_get_s(annotationObj, L"type", &type)) {
                    double x, y, width, height;
                    get_rect(annotationObj, pageHeight, &x, &y, &width, &height);
                    PdfRect rect(x, y, width, height);
                    if(type.find((const uint8_t *)"text") != CUTF8String::npos) {
                        if(insert_text_annotation(annotationObj, page, &rect, document)) {
                            continue;
                        }
                    }
                    
                    if(type.find((const uint8_t *)"stamp") != CUTF8String::npos) {
                        if(insert_stamp_annotation(annotationObj, page, &rect, document)) {
                            continue;
                        }
                    }
                    
                    if(type.find((const uint8_t *)"link") != CUTF8String::npos) {
                        if(insert_link_annotation(annotationObj, page, &rect, document)) {
                            continue;
                        }
                    }
                    
                }
            }
        }
    }
}

static void insert_field(PA_ObjectRef pageObj, double pageHeight, PdfPage *page, PdfDocument *document) {
    
    std::map<CUTF8String, PdfField> fields;
    int fieldCount = page->GetNumFields();
    for(int f = 0; f < fieldCount; ++f) {
        PdfField _field = page->GetField(f);
        CUTF8String _name((const uint8_t *)_field.GetFieldName().GetStringUtf8().c_str());
        fields.insert(std::map<CUTF8String, PdfField>::value_type(_name, _field));
    }
    
    PA_CollectionRef fieldsCol = ob_get_c(pageObj, L"fields");
    if(fieldsCol) {
        for(PA_long32 f = 0; f < PA_GetCollectionLength(fieldsCol);++f) {
            
            PA_ObjectRef fieldObj = getObjectInCollection(fieldsCol, f);
            
            if(fieldObj) {
                CUTF8String type;
                if(ob_get_s(fieldObj, L"type", &type)) {
                    
                    CUTF8String fieldName;
                    if(ob_get_s(fieldObj, L"fieldName", &fieldName)) {
                        
                        double width  = ob_get_n(fieldObj, L"width" );
                        double height = ob_get_n(fieldObj, L"height");
                        double x      = ob_get_n(fieldObj, L"x"  );
                        double y      = ob_get_n(fieldObj, L"y");
                        
                        CUTF8String unit;
                        if(ob_get_s(fieldObj, L"unit", &unit)) {
                            if(unit.find((const uint8_t *)"mm") != CUTF8String::npos) {
                                width  = 72.0 * width  / 25.4;
                                height = 72.0 * height / 25.4;
                                x      = 72.0 * x      / 25.4;
                                y      = 72.0 * y      / 25.4;
                            }
                            if(unit.find((const uint8_t *)"in") != CUTF8String::npos) {
                                width  = 72.0 * width  ;
                                height = 72.0 * height ;
                                x      = 72.0 * x      ;
                                y      = 72.0 * y      ;
                            }
                        }
                        
                        y = pageHeight - y - height;
                        PdfRect rect(x, y, width, height);
                        
                        if(process_textfield(type,
                                             fieldName,
                                             fields,
                                             rect,
                                             fieldObj,
                                             page, document)) {
                            continue;
                        }
                        
                        if(process_checkbox(type,
                                            fieldName,
                                            fields,
                                            rect,
                                            fieldObj,
                                            page, document)) {
                            continue;
                        }
                        
                        if(process_pushbutton(type,
                                              fieldName,
                                              fields,
                                              rect,
                                              fieldObj,
                                              page, document)) {
                            continue;
                        }
                        
                        if(process_radiobutton(type,
                                               fieldName,
                                               fields,
                                               rect,
                                               fieldObj,
                                               page, document)) {
                            continue;
                        }
                        
                        if(process_listbox(type,
                                           fieldName,
                                           fields,
                                           rect,
                                           fieldObj,
                                           page, document)) {
                            continue;
                        }
                        
                        if(process_combobox(type,
                                            fieldName,
                                            fields,
                                            rect,
                                            fieldObj,
                                            page, document)) {
                            continue;
                        }
                        
                    }
                }
            }
        }
    }
}

#pragma mark action

static EPdfAction get_action_type(PA_ObjectRef fieldObj) {
    
    EPdfAction action = ePdfAction_Unknown;
    
    CUTF8String textValue;
    get_param_string(fieldObj, L"action", &textValue);
    
    if(textValue.length()) {
        if(textValue.find((const uint8_t *)"link") != CUTF8String::npos) {
            action = ePdfAction_URI;
        }else
            if(textValue.find((const uint8_t *)"submit") != CUTF8String::npos) {
                action = ePdfAction_SubmitForm;
            }else
                if(textValue.find((const uint8_t *)"reset") != CUTF8String::npos) {
                    action = ePdfAction_ResetForm;
                }else
                    if(textValue.find((const uint8_t *)"script") != CUTF8String::npos) {
                        action = ePdfAction_JavaScript;
                    }
    }
     
    return action;
}

static void set_field_action(PdfField *field, PA_ObjectRef fieldObj, PdfMemDocument *document) {
    
    EPdfAction actionType = get_action_type(fieldObj);
    if(actionType != ePdfAction_Unknown) {
        PdfAction action(actionType, document);
        
        CUTF8String textValue;
        get_param_string(fieldObj, L"URI", &textValue);
        
        if(textValue.length()) {
            PdfString location((const char *)textValue.c_str());//this must NOT be unicode!
            action.SetURI(location);
        }
        
        get_param_string(fieldObj, L"script", &textValue);
        if(textValue.length()) {
            PdfString code((const pdf_utf8 *)textValue.c_str());
            action.SetScript(code);
            document->SetPdfVersion(ePdfVersion_1_5);
        }
        
        PdfAnnotation *annotation = field->GetWidgetAnnotation();
        annotation->SetAction(action);
        
        PA_CollectionRef eventsCol = ob_get_c(fieldObj, L"events");
        if(eventsCol) {
            
            for(PA_long32 i = 0; i < PA_GetCollectionLength(eventsCol); ++i) {
                PA_ObjectRef event = getObjectInCollection(eventsCol, i);
                if(event) {

                    get_param_string(event, L"event", &textValue);
                    if(textValue.find((const uint8_t *)"mouseEnter") != CUTF8String::npos) {
                        field->SetMouseEnterAction(action);
                        
                    }
                    if(textValue.find((const uint8_t *)"mouseLeave") != CUTF8String::npos) {
                        field->SetMouseLeaveAction(action);
                        
                    }
                    if(textValue.find((const uint8_t *)"mouseDown") != CUTF8String::npos) {
                        field->SetMouseDownAction(action);
                        
                    }
                    if(textValue.find((const uint8_t *)"mouseUp") != CUTF8String::npos) {
                        field->SetMouseUpAction(action);
                        
                    }
                    if(textValue.find((const uint8_t *)"focusEnter") != CUTF8String::npos) {
                        field->SetFocusEnterAction(action);
                        
                    }
                    if(textValue.find((const uint8_t *)"focusLeave") != CUTF8String::npos) {
                        field->SetFocusLeaveAction(action);
                        
                    }
                    
                }
            }
        }
    }
}

#pragma mark sign

void podofo_sign_document(PA_PluginParameters params) {
    
    PdfError::EnableLogging(false);
    PdfError::EnableDebug(false);
    
    PA_ObjectRef param = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    PA_Picture pdf_in = ob_get_p(param, L"in");
    
    C_BLOB pdf;
    get_picture_data(pdf_in, "pdf", pdf);
    
    CUTF8String param_in, param_out;
    
    if(pdf.getBytesLength()) {
        param_in = (const uint8_t *)"-";
    }else{
        get_param_path(param, L"in" , &param_in);
        get_param_path(param, L"out", &param_out);
    }
    
    bool inMem = pdf.getBytesLength();
    
    bool param_replace = ob_get_b(param, L"replace");
        
    CUTF8String param_password;
    get_param_string(param, L"password", &param_password);
    
    CUTF8String param_reason;
    get_param_string(param, L"reason", &param_reason);
    
    CUTF8String param_field;
    get_param_string(param, L"field", &param_field);
    
    int annot_page = get_param_integer(param, L"page");
    
#ifdef _WIN32
    CUTF16String w_param_in, w_param_out;
    u8_to_u16(param_in,  w_param_in );
    u8_to_u16(param_out, w_param_out);
    const wchar_t *inputfile  = param_in .length() ? (const wchar_t *)w_param_in .c_str() : NULL;
    const wchar_t *outputfile = param_out.length() ? (const wchar_t *)w_param_out.c_str() : NULL;
#else
    const char *inputfile  = param_in .length() ? (const char *)param_in .c_str() : NULL;
    const char *outputfile = param_out.length() ? (const char *)param_out.c_str() : NULL;
#endif

    if(inputfile && param_in.compare(param_out)) {

        X509    *cert = NULL;
        EVP_PKEY *key = NULL;
        BIO *bio_cert = NULL;
        BIO *bio_key  = NULL;
        
        pdf_int32 min_signature_size = get_signature_objects(param,
                                                             &cert, &key, &bio_cert, &bio_key);

        if(bio_key) {
            if(key) {
                if(bio_cert) {
                    if(cert) {
                        
                        PdfSignatureField *pSignField = NULL;
                        PdfAnnotation *pTemporaryAnnot = NULL; // for existing signature fields
                        
                        try
                        {
                            PdfMemDocument document;
                            
                            if(param_password.length()) {
                                document.SetPassword((const char *)param_password.c_str());
                            }
                            
                            if(pdf.getBytesLength()) {
                                document.LoadFromBuffer((const char*)pdf.getBytesPtr(), (long)pdf.getBytesLength(), true);
                            }else{
                                document.Load(inputfile, true);
                            }
                            
                            if(document.GetPageCount()) {
                                
                                PdfAcroForm* pAcroForm = document.GetAcroForm();
                                if( !pAcroForm )
                                    PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "acroForm == NULL" );
                                
                                if( !pAcroForm->GetObject()->GetDictionary().HasKey( PdfName( "SigFlags" ) ) ||
                                   !pAcroForm->GetObject()->GetDictionary().GetKey( PdfName( "SigFlags" ) )->IsNumber() ||
                                   pAcroForm->GetObject()->GetDictionary().GetKeyAsLong( PdfName( "SigFlags" ) ) != 3 )
                                {
                                    if( pAcroForm->GetObject()->GetDictionary().HasKey( PdfName( "SigFlags" ) ) )
                                        pAcroForm->GetObject()->GetDictionary().RemoveKey( PdfName( "SigFlags" ) );
                                    
                                    pdf_int64 val = 3;
                                    pAcroForm->GetObject()->GetDictionary().AddKey( PdfName( "SigFlags" ), PdfObject( val ) );
                                }
                                
                                if( pAcroForm->GetNeedAppearances() )
                                {
                                    pAcroForm->SetNeedAppearances( false );
                                }

                                /*
                                 
                                 this crashes

                                 PdfRefCountedBuffer outputbuffer;
                                 PdfOutputDevice outputDevice;
                                 
                                 outputDevice = inMem ? PdfOutputDevice(&outputbuffer) : PdfOutputDevice(outputfile ? outputfile : inputfile, outputfile != NULL );
                                 PdfSignOutputDevice signer( &outputDevice );
                                 
                                 */

                                PdfRefCountedBuffer outputbuffer;
                                PdfOutputDevice outputDeviceForBuffer(&outputbuffer);
                                PdfSignOutputDevice signerForBuffer( &outputDeviceForBuffer );
                                
                                PdfOutputDevice *outputDevice = NULL;
                                if(!inMem) {
                                    outputDevice = new PdfOutputDevice(outputfile ? outputfile : inputfile, outputfile != NULL );
                                }

                                PdfSignOutputDevice signer(outputDevice);
                                
                                PdfString name;
                                PdfObject *pExistingSigField = NULL;
                                
                                if(param_field.length()) {
                                    name = PdfString((const pdf_utf8 *)param_field.c_str());
                                    pExistingSigField = find_existing_signature_field(pAcroForm, name);
                                    if( pExistingSigField && !param_replace) {
                                        std::string err = "Signature field named '";
                                        err += name.GetString();
                                        err += "' already exists";
                                        PODOFO_RAISE_ERROR_INFO( ePdfError_WrongDestinationType, err.c_str() );
                                    }
                                }
                                else
                                {
                                    char fldName[96]; // use bigger buffer to make sure sprintf does not overflow
                                    sprintf(fldName,
                                            "PodofoSignatureField%" PDF_FORMAT_INT64,
                                            static_cast<pdf_int64>(document.GetObjects().GetObjectCount()));
                                    name = PdfString(fldName);
                                }
                                
                                if(pExistingSigField) {
                                    if(!pExistingSigField->GetDictionary().HasKey("P")) {
                                        std::string err = "Signature field named '";
                                        err += name.GetString();
                                        err += "' doesn't have a page reference";
                                        PODOFO_RAISE_ERROR_INFO( ePdfError_PageNotFound, err.c_str() );
                                    }
                                    
                                    PdfPage *pPage;
                                    pPage = document.GetPagesTree()->GetPage(
                                                                             pExistingSigField->GetDictionary().GetKey("P")->GetReference());
                                    if(!pPage)
                                        PODOFO_RAISE_ERROR( ePdfError_PageNotFound );
                                    
                                    pTemporaryAnnot = new PdfAnnotation(pExistingSigField, pPage);
                                    if(!pTemporaryAnnot)
                                        PODOFO_RAISE_ERROR_INFO(
                                                                ePdfError_OutOfMemory,
                                                                "Cannot allocate annotation object for existing signature field");
                                    
                                    pSignField = new PdfSignatureField( pTemporaryAnnot );
                                    if(!pSignField)
                                        PODOFO_RAISE_ERROR_INFO(
                                                                ePdfError_OutOfMemory,
                                                                "Cannot allocate existing signature field object");
                                    
                                    pSignField->EnsureSignatureObject();
                                }
                                else
                                {
                                    if(annot_page > 0) {
                                        annot_page--;//adjust to 0-based index
                                    }
                                    
                                    PdfPage *pPage = document.GetPage(annot_page);
                                    if(!pPage)
                                        PODOFO_RAISE_ERROR(ePdfError_PageNotFound);
                                    
                                    double pageHeight = pPage->GetPageSize().GetHeight();
                                    
                                    /*
                                     
                                     annotations
                                     
                                     */

                                    PA_CollectionRef pagesCol = ob_get_c(param, L"pages");
                                    
                                    if(pagesCol) {
                                        int pageCount = document.GetPageCount();
                                        PA_long32 pageLength = PA_GetCollectionLength(pagesCol);
                                        pageCount = pageCount < pageLength ? pageCount : pageLength;
                                        
                                        for(int i = 0; i < pageCount;++i) {
                                            PA_ObjectRef pageObj = getObjectInCollection(pagesCol, i);
                                            if(pageObj) {
                                                
                                                PdfPage *page = document.GetPage(i);
                                                insert_text(pageObj, pageHeight, page, &document);
                                                insert_annotation(pageObj, pageHeight, page, &document);
                                            }
                                        }
                                    }
 
                                    double sign_x = 0.0, sign_y = 0.0, sign_width = 0.0, sign_height = 0.0;
                                    
                                    sign_x      = convert_to_pdf_unit(param, L"x");
                                    sign_y      = convert_to_pdf_unit(param, L"y");
                                    sign_width  = convert_to_pdf_unit(param, L"width");
                                    sign_height = convert_to_pdf_unit(param, L"height");
                                    
                                    sign_y = pageHeight - sign_y - sign_height;
                                    PdfRect sign_rect(sign_x, sign_y, sign_width, sign_height);

                                    PdfAnnotation *pAnnot = pPage->CreateAnnotation(ePdfAnnotation_Widget, sign_rect);
                                    if(!pAnnot)
                                        PODOFO_RAISE_ERROR_INFO(ePdfError_OutOfMemory, "Cannot allocate annotation object" );
                                    
                                    pSignField = new PdfSignatureField( pAnnot, pAcroForm, &document );
                                    if( !pSignField )
                                        PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, "Cannot allocate signature field object" );
                                    
                                    if((sign_width == 0.0) && (sign_height == 0.0)) {
                                        pAnnot->SetFlags( ePdfAnnotationFlags_Invisible | ePdfAnnotationFlags_Hidden );
                                    }else{
                                        pAnnot->SetFlags( ePdfAnnotationFlags_Print );
                                        PdfXObject sigXObject( sign_rect, &document );
                                        PdfPainter painter;
                                        try
                                        {
                                            painter.SetPage( &sigXObject );
                                            
                                            /* Workaround Adobe's reader error 'Expected a dict object.' when the stream
                                             contains only one object which does Save()/Restore() on its own, like
                                             the image XObject. */
                                            painter.Save();
                                            painter.Restore();
                                            
                                            pSignField->SetAppearanceStream( &sigXObject );
                                        }
                                        catch( PdfError & e )
                                        {
                                            if( painter.GetPage() )
                                            {
                                                try
                                                {
                                                    painter.FinishPage();
                                                }
                                                catch( ... )
                                                {
                                                }
                                            }
                                        }
                                        painter.FinishPage();
                                    }

                                }
                                
                                if(inMem) {
                                    signerForBuffer.SetSignatureSize(min_signature_size);
                                }else{
                                    signer.SetSignatureSize(min_signature_size);
                                }

                                //TODO: timer server support???
                                pSignField->SetFieldName(name);
                                pSignField->SetSignatureReason( PdfString(reinterpret_cast<const pdf_utf8 *>(param_reason.c_str())));
                                
                                CUTF8String textValue;
                                get_param_string(param, L"certification", &textValue);
                                if(textValue.length()) {
                                    PdfObject *catalog = document.GetCatalog();
                                    if(catalog) {
                                        if(textValue.find((const uint8_t *)"noPerms") != CUTF8String::npos) {
                                            pSignField->AddCertificationReference(catalog, PoDoFo::PdfSignatureField::ePdfCertPermission_NoPerms);
                                        }
                                        if(textValue.find((const uint8_t *)"formFill") != CUTF8String::npos) {
                                            pSignField->AddCertificationReference(catalog, PoDoFo::PdfSignatureField::ePdfCertPermission_FormFill);
                                        }
                                        if(textValue.find((const uint8_t *)"annotations") != CUTF8String::npos) {
                                            pSignField->AddCertificationReference(catalog, PoDoFo::PdfSignatureField::ePdfCertPermission_Annotations);
                                        }
                                    }
                                }
                                
                                pSignField->SetSignatureDate(PdfDate());

                                get_param_string(param, L"location", &textValue);
                                if(textValue.length()) {
                                    pSignField->SetSignatureLocation(PdfString(reinterpret_cast<const pdf_utf8 *>(textValue.c_str())));
                                }

                                if(inMem) {
                                    pSignField->SetSignature(*signerForBuffer.GetSignatureBeacon());
                                    document.WriteUpdate(&signerForBuffer, true);
                                }else{
                                    pSignField->SetSignature(*signer.GetSignatureBeacon());
                                    document.WriteUpdate(&signer, outputfile != NULL);
                                }
                                
                                if(inMem) {
                                    if(!signerForBuffer.HasSignaturePosition()) {
                                        PODOFO_RAISE_ERROR_INFO(ePdfError_SignatureError,
                                                                "Cannot find signature position in the document data");
                                    }
                                }else{
                                    if(!signer.HasSignaturePosition()) {
                                        PODOFO_RAISE_ERROR_INFO(ePdfError_SignatureError,
                                                                "Cannot find signature position in the document data");
                                    }
                                }

                                if(inMem) {
                                    // Adjust ByteRange for signature
                                    signerForBuffer.AdjustByteRange();
                                    
                                    // Read data for signature and count it
                                    // We seek at the beginning of the file
                                    signerForBuffer.Seek(0);
                                    sign_with_signer(signerForBuffer, cert, key);
                                    signerForBuffer.Flush();
                                }else{
                                    // Adjust ByteRange for signature
                                    signer.AdjustByteRange();
                                    
                                    // Read data for signature and count it
                                    // We seek at the beginning of the file
                                    signer.Seek(0);
                                    sign_with_signer(signer, cert, key);
                                    signer.Flush();
                                    
                                }

                                if(inMem) {
                                    PA_Picture pdf_out = PA_CreatePicture((void *)outputbuffer.GetBuffer(), (PA_long32)outputbuffer.GetSize());
                                    ob_set_p(returnValue, L"out", pdf_out);
                                }
                                
                                if(outputDevice)
                                    delete outputDevice;

                            }
                            
                        }catch( PdfError & e )
                        {
                            ob_set_n(returnValue, L"error", e.GetError());
                            ob_set_s(returnValue, L"errorDescription", e.what());
                            ob_set_s(returnValue, L"errorMessage", PdfError::ErrorMessage(e.GetError()));
                            
                            e.PrintErrorMsg();
                        }
                        
                        if(pSignField)
                            delete pSignField;
                        
                        if(pTemporaryAnnot)
                            delete pTemporaryAnnot;

                        X509_free(cert);
                    }
                    BIO_free(bio_cert);
                }
                EVP_PKEY_free(key);
            }
            BIO_free(bio_key);
        }
        
    }
    
#ifndef PODOFO_HAVE_OPENSSL_1_1
    ERR_free_strings();
#endif
    
    PA_ReturnObject(params, returnValue);
}

#pragma mark get prop

static void get_page_properties(PdfPage *page, PA_ObjectRef pageObj) {
    
    ob_set_n(pageObj, L"pageNumber", page->GetPageNumber());
    ob_set_n(pageObj, L"rotation",   page->GetRotation());
    
    PA_ObjectRef boxObj = PA_CreateObject();
    ob_set_box(boxObj, L"media", page->GetMediaBox());
    ob_set_box(boxObj, L"crop",  page->GetCropBox());
    ob_set_box(boxObj, L"trim",  page->GetTrimBox());
    ob_set_box(boxObj, L"bleed", page->GetBleedBox());
    ob_set_box(boxObj, L"art",   page->GetArtBox());
    ob_set_o(pageObj, "rect", boxObj);
}

static void get_annotation_properties(PdfAnnotation *annotation, double pageHeight, PA_ObjectRef fieldObj) {
        
    ob_set_b(fieldObj, L"open", annotation->GetOpen());

    PdfRect rect = annotation->GetRect();
//    PA_ObjectRef rectObj = PA_CreateObject();
    
    ob_set_n(fieldObj, L"x", rect.GetLeft());
    ob_set_n(fieldObj, L"y", pageHeight - rect.GetBottom() - rect.GetHeight());
    ob_set_n(fieldObj, L"width", rect.GetWidth());
    ob_set_n(fieldObj, L"height", rect.GetHeight());
//    ob_set_o(fieldObj, L"rect", rectObj);
    
    PdfArray colors = annotation->GetColor();
    
    switch (colors.GetSize()) {
        case 0://transparent
            ob_set_0(fieldObj, L"color");
            break;
        case 1://mono
            ob_set_n(fieldObj, L"color", colors[0].GetReal());
            break;
        case 3://rgb
        {
            PA_ObjectRef colorObj = PA_CreateObject();
            ob_set_n(colorObj, L"r", colors[0].GetReal());
            ob_set_n(colorObj, L"g", colors[1].GetReal());
            ob_set_n(colorObj, L"b", colors[2].GetReal());
            ob_set_o(fieldObj, L"color", colorObj);
        }
            break;
        case 4://cmyk
        {
            PA_ObjectRef colorObj = PA_CreateObject();
            ob_set_n(colorObj, L"c", colors[0].GetReal());
            ob_set_n(colorObj, L"m", colors[1].GetReal());
            ob_set_n(colorObj, L"y", colors[2].GetReal());
            ob_set_n(colorObj, L"k", colors[3].GetReal());
            ob_set_o(fieldObj, L"color", colorObj);
        }
            break;
        default:
            break;
    }
    
    if(annotation->HasAction()) {
        PdfAction *action = annotation->GetAction();
        if(action) {
            EPdfAction actionType = action->GetType();
            switch (actionType) {
                case ePdfAction_GoTo:
                    ob_set_s(fieldObj, L"action", "goTo");
                    break;
                case ePdfAction_GoToR:
                    ob_set_s(fieldObj, L"action", "goToR");
                    break;
                case ePdfAction_GoToE:
                    ob_set_s(fieldObj, L"action", "goToE");
                    break;
                case ePdfAction_Launch:
                    ob_set_s(fieldObj, L"action", "launch");
                    break;
                case ePdfAction_Thread:
                    ob_set_s(fieldObj, L"action", "thread");
                    break;
                case ePdfAction_URI:
                {
                    ob_set_s(fieldObj, L"action", "URI");
                    if(action->HasURI()) {
                        ob_set_s(fieldObj, L"URI", action->GetURI().GetStringUtf8().c_str());
                    }
                }
                    break;
                case ePdfAction_Sound:
                    ob_set_s(fieldObj, L"action", "sound");
                    break;
                case ePdfAction_Movie:
                    ob_set_s(fieldObj, L"action", "movie");
                    break;
                case ePdfAction_Hide:
                    ob_set_s(fieldObj, L"action", "hide");
                    break;
                case ePdfAction_Named:
                    ob_set_s(fieldObj, L"action", "named");
                    break;
                case ePdfAction_SubmitForm:
                    ob_set_s(fieldObj, L"action", "submitForm");
                    break;
                case ePdfAction_ResetForm:
                    ob_set_s(fieldObj, L"action", "resetForm");
                    break;
                case ePdfAction_ImportData:
                    ob_set_s(fieldObj, L"action", "importData");
                    break;
                case ePdfAction_JavaScript:
                {
                    ob_set_s(fieldObj, L"action", "script");
                    if(action->HasScript()) {
                        ob_set_s(fieldObj, L"script", action->GetScript().GetStringUtf8().c_str());
                    }
                }
                    break;
                case ePdfAction_SetOCGState:
                    ob_set_s(fieldObj, L"action", "setOCGState");
                    break;
                case ePdfAction_Rendition:
                    ob_set_s(fieldObj, L"action", "rendition");
                    break;
                case ePdfAction_Trans:
                    ob_set_s(fieldObj, L"action", "trans");
                    break;
                case ePdfAction_GoTo3DView:
                    ob_set_s(fieldObj, L"action", "goTo3DView");
                    break;
                case ePdfAction_RichMediaExecute:
                    ob_set_s(fieldObj, L"action", "richMediaExecute");
                    break;
                default:
                    break;
            }
            
        }
    }
}

static void get_field_properties(PdfField *field, PA_ObjectRef fieldObj) {
    
    ob_set_s(fieldObj, L"fieldName", field->GetFieldName().GetStringUtf8().c_str());
    ob_set_s(fieldObj, L"alternateName", field->GetAlternateName().GetStringUtf8().c_str());
    
    /*
     skip export related features
     ob_set_s(fieldObj, L"mappingName", field.GetMappingName().GetStringUtf8().c_str());
     */

    ob_set_b(fieldObj, L"isReadOnly", field->IsReadOnly());
    ob_set_b(fieldObj, L"isRequired", field->IsRequired());

    get_annotation_properties(field->GetWidgetAnnotation(),
                              field->GetPage()->GetPageSize().GetHeight(), fieldObj);
    
    EPdfHighlightingMode highlightingMode = field->GetHighlightingMode();
    
    switch (highlightingMode) {
        case ePdfHighlightingMode_None:
            ob_set_s(fieldObj, L"highlightingMode", "none");
            break;
        case ePdfHighlightingMode_Invert:
            ob_set_s(fieldObj, L"highlightingMode", "invert");
            break;
        case ePdfHighlightingMode_InvertOutline:
            ob_set_s(fieldObj, L"highlightingMode", "invertOutline");
            break;
        case ePdfHighlightingMode_Push:
            ob_set_s(fieldObj, L"highlightingMode", "push");
            break;
        default:
            ob_set_s(fieldObj, L"highlightingMode", "unknown");
            break;
    }
    
    PdfAnnotation *annotation = field->GetWidgetAnnotation();
    
    if(annotation->HasAction()) {
        PdfAction *action = annotation->GetAction();
        if(action) {
            EPdfAction actionType = action->GetType();
            switch (actionType) {
                case ePdfAction_GoTo:
                    ob_set_s(fieldObj, L"action", "goTo");
                    break;
                case ePdfAction_GoToR:
                    ob_set_s(fieldObj, L"action", "goToR");
                    break;
                case ePdfAction_GoToE:
                    ob_set_s(fieldObj, L"action", "goToE");
                    break;
                case ePdfAction_Launch:
                    ob_set_s(fieldObj, L"action", "launch");
                    break;
                case ePdfAction_Thread:
                    ob_set_s(fieldObj, L"action", "thread");
                    break;
                case ePdfAction_URI:
                {
                    ob_set_s(fieldObj, L"action", "URI");
                    if(action->HasURI()) {
                        ob_set_s(fieldObj, L"URI", action->GetURI().GetStringUtf8().c_str());
                    }
                }
                    break;
                case ePdfAction_Sound:
                    ob_set_s(fieldObj, L"action", "sound");
                    break;
                case ePdfAction_Movie:
                    ob_set_s(fieldObj, L"action", "movie");
                    break;
                case ePdfAction_Hide:
                    ob_set_s(fieldObj, L"action", "hide");
                    break;
                case ePdfAction_Named:
                    ob_set_s(fieldObj, L"action", "named");
                    break;
                case ePdfAction_SubmitForm:
                    ob_set_s(fieldObj, L"action", "submitForm");
                    break;
                case ePdfAction_ResetForm:
                    ob_set_s(fieldObj, L"action", "resetForm");
                    break;
                case ePdfAction_ImportData:
                    ob_set_s(fieldObj, L"action", "importData");
                    break;
                case ePdfAction_JavaScript:
                {
                    ob_set_s(fieldObj, L"action", "script");
                    if(action->HasScript()) {
                        ob_set_s(fieldObj, L"script", action->GetScript().GetStringUtf8().c_str());
                    }
                }
                    break;
                case ePdfAction_SetOCGState:
                    ob_set_s(fieldObj, L"action", "setOCGState");
                    break;
                case ePdfAction_Rendition:
                    ob_set_s(fieldObj, L"action", "rendition");
                    break;
                case ePdfAction_Trans:
                    ob_set_s(fieldObj, L"action", "trans");
                    break;
                case ePdfAction_GoTo3DView:
                    ob_set_s(fieldObj, L"action", "goTo3DView");
                    break;
                case ePdfAction_RichMediaExecute:
                    ob_set_s(fieldObj, L"action", "richMediaExecute");
                    break;
                default:
                    break;
            }
        }
    }
}

static void get_pushbutton_properties(PdfPushButton *pushButton, PA_ObjectRef fieldObj) {

    PA_ObjectRef caption = PA_CreateObject();
    ob_set_s(caption, L"normal", pushButton->GetCaption().GetStringUtf8().c_str());
    ob_set_s(caption, L"rollover", pushButton->GetRolloverCaption().GetStringUtf8().c_str());
    ob_set_s(caption, L"alternate", pushButton->GetAlternateCaption().GetStringUtf8().c_str());
    ob_set_o(fieldObj, L"captions", caption);
    
    ob_set_s(fieldObj, L"type", "pushButton");
}

static void get_checkbox_properties(PdfCheckBox *checkBox, PA_ObjectRef fieldObj) {
    
    ob_set_s(fieldObj, L"caption", checkBox->GetCaption().GetStringUtf8().c_str());
    ob_set_b(fieldObj, L"isChecked", checkBox->IsChecked());
    
    ob_set_s(fieldObj, L"type", "checkBox");
}

static void get_radiobutton_properties(PdfButton *button, PA_ObjectRef fieldObj) {

    ob_set_s(fieldObj, L"caption", button->GetCaption().GetStringUtf8().c_str());
        
    ob_set_s(fieldObj, L"type", "radioButton");
}

static void get_button_properties(PdfButton *button, PA_ObjectRef fieldObj) {

    if(button->IsPushButton()) {
        get_pushbutton_properties((PdfPushButton *)button, fieldObj);
    }

    if(button->IsCheckBox()) {
        get_checkbox_properties((PdfCheckBox *)button, fieldObj);
    }

    if(button->IsRadioButton()) {
        get_radiobutton_properties(button, fieldObj);
    }

}

static void get_textfield_properties(PdfTextField *textField, PA_ObjectRef fieldObj) {
    
    ob_set_s(fieldObj, L"value", textField->GetText().GetStringUtf8().c_str());
    ob_set_n(fieldObj, L"maxLen", textField->GetMaxLen());
    ob_set_b(fieldObj, L"isMultiLine", textField->IsMultiLine());
    ob_set_b(fieldObj, L"isPasswordField", textField->IsPasswordField());
    ob_set_b(fieldObj, L"isFileField", textField->IsFileField());
    ob_set_b(fieldObj, L"isSpellcheckingEnabled", textField->IsSpellcheckingEnabled());
    ob_set_b(fieldObj, L"isScrollBarsEnabled", textField->IsScrollBarsEnabled());
    ob_set_b(fieldObj, L"isCombs", textField->IsCombs());
    ob_set_b(fieldObj, L"isRichText", textField->IsRichText());
 
    ob_set_s(fieldObj, L"type", "textField");
}

static void get_comboboxfield_properties(PdfComboBox *comboBox, PA_ObjectRef fieldObj) {
    
    ob_set_b(fieldObj, L"isEditable", comboBox->IsEditable());
    
    ob_set_s(fieldObj, L"type", "comboBox");
}

static void get_listfield_properties(PdfListField *listField, PA_ObjectRef fieldObj) {
     
    ob_set_b(fieldObj, L"isMultiSelect", listField->IsMultiSelect());
    ob_set_b(fieldObj, L"isCommitOnSelectionChange", listField->IsCommitOnSelectionChange());
    ob_set_b(fieldObj, L"isSorted", listField->IsSorted());
  
    PA_CollectionRef items = PA_CreateCollection();
    for(int item = 0; item <static_cast<int>(listField->GetItemCount()); ++item) {
        PA_ObjectRef itemObj = PA_CreateObject();
        ob_set_s(itemObj, L"displayText", listField->GetItemDisplayText(item).GetStringUtf8().c_str());
        ob_set_s(itemObj, L"value", listField->GetItem(item).GetStringUtf8().c_str());
        collection_push(items, itemObj);
    }
    
    ob_set_c(fieldObj, L"items", items);
    ob_set_n(fieldObj, L"currentItem", listField->GetSelectedItem());
    ob_set_b(fieldObj, L"isSpellcheckingEnabled", listField->IsSpellcheckingEnabled());

    if(listField->IsComboBox()) {
        get_comboboxfield_properties((PdfComboBox *)listField, fieldObj);
    }else{
        ob_set_s(fieldObj, L"type", "listBox");
    }
    
}

static void get_rect(PA_ObjectRef annotationObj, double pageHeight, double *x, double *y, double *width, double *height) {
    
    double _width  = ob_get_n(annotationObj, L"width" );
    double _height = ob_get_n(annotationObj, L"height");
    double _x      = ob_get_n(annotationObj, L"x"  );
    double _y      = ob_get_n(annotationObj, L"y");
    
    CUTF8String unit;
    if(ob_get_s(annotationObj, L"unit", &unit)) {
        if(unit.find((const uint8_t *)"mm") != CUTF8String::npos) {
            _width  = 72.0 * _width  / 25.4;
            _height = 72.0 * _height / 25.4;
            _x      = 72.0 * _x      / 25.4;
            _y      = 72.0 * _y      / 25.4;
        }
        if(unit.find((const uint8_t *)"in") != CUTF8String::npos) {
            _width  = 72.0 * _width  ;
            _height = 72.0 * _height ;
            _x      = 72.0 * _x      ;
            _y      = 72.0 * _y      ;
        }
    }
    
    _y = pageHeight - _y - _height;
    
    *x = _x;
    *y = _y;
    *width = _width;
    *height = _height;
}

#pragma mark podofo get

void podofo_get_form(PA_PluginParameters params) {

    PdfError::EnableLogging(false);
    PdfError::EnableDebug(false);
    
    PA_ObjectRef param = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    PA_CollectionRef pagesCol = PA_CreateCollection();
    
    PA_Picture pdf_in = ob_get_p(param, L"in");
    
    C_BLOB pdf;
    get_picture_data(pdf_in, "pdf", pdf);

    CUTF8String param_in;
    
    if(pdf.getBytesLength()) {
        param_in = (const uint8_t *)"-";
    }else{
        get_param_path(param, L"in" , &param_in);
    }

    CUTF8String param_password;
    get_param_string(param, L"password", &param_password);
    
#ifdef _WIN32
    CUTF16String w_param_in;
    u8_to_u16(param_in,  w_param_in);
    const wchar_t *inputfile  = param_in .length() ? (const wchar_t *)w_param_in .c_str() : NULL;
#else
    const char *inputfile  = param_in .length() ? (const char *)param_in .c_str() : NULL;
#endif
    
    if(inputfile) {

        try
        {
            PdfMemDocument document;
            
            if(param_password.length()) {
                document.SetPassword((const char *)param_password.c_str());
            }

            if(pdf.getBytesLength()) {
                document.LoadFromBuffer((const char*)pdf.getBytesPtr(), (long)pdf.getBytesLength());
            }else{
                document.Load(inputfile, true);
            }

            int pageCount = document.GetPageCount();
            
            for(int i = 0; i < pageCount;++i) {
                
                PdfPage *page = document.GetPage(i);
                PA_ObjectRef pageObj = PA_CreateObject();
                
                get_page_properties(page, pageObj);
                
                int annotationCount = page->GetNumAnnots();
                
                PA_CollectionRef annotations = PA_CreateCollection();
                
                for(int a = 0; a < annotationCount; ++a) {
                                    
                    PdfAnnotation *annotation = page->GetAnnotation(a);
                    EPdfAnnotation annotationType = annotation->GetType();
                                    
                    PA_ObjectRef annotationObj = PA_CreateObject();

                    get_annotation_properties(annotation,
                                              page->GetPageSize().GetHeight(),
                                              annotationObj);

                    try{
                        switch (annotationType) {
                            case ePdfAnnotation_Text:
                                ob_set_s(annotationObj, L"type", "text");
                                break;
                            case ePdfAnnotation_Link:
                                ob_set_s(annotationObj, L"type", "link");
                                break;
                            case ePdfAnnotation_FreeText:
                                ob_set_s(annotationObj, L"type", "freeText");
                                break;
                            case ePdfAnnotation_Line:
                                ob_set_s(annotationObj, L"type", "line");
                                break;
                            case ePdfAnnotation_Square:
                                ob_set_s(annotationObj, L"type", "square");
                                break;
                            case ePdfAnnotation_Circle:
                                ob_set_s(annotationObj, L"type", "circle");
                                break;
                            case ePdfAnnotation_Polygon:
                                ob_set_s(annotationObj, L"type", "polygon");
                                break;
                            case ePdfAnnotation_PolyLine:
                                ob_set_s(annotationObj, L"type", "polyLine");
                                break;
                            case ePdfAnnotation_Highlight:
                                ob_set_s(annotationObj, L"type", "highlight");
                                break;
                            case ePdfAnnotation_Underline:
                                ob_set_s(annotationObj, L"type", "underline");
                                break;
                            case ePdfAnnotation_Squiggly:
                                ob_set_s(annotationObj, L"type", "squiggly");
                                break;
                            case ePdfAnnotation_StrikeOut:
                                ob_set_s(annotationObj, L"type", "strikeOut");
                                break;
                            case ePdfAnnotation_Stamp:
                                ob_set_s(annotationObj, L"type", "stamp");
                                break;
                            case ePdfAnnotation_Caret:
                                ob_set_s(annotationObj, L"type", "caret");
                                break;
                            case ePdfAnnotation_Ink:
                                ob_set_s(annotationObj, L"type", "ink");
                                break;
                            case ePdfAnnotation_Popup:
                                ob_set_s(annotationObj, L"type", "popup");
                                break;
                            case ePdfAnnotation_FileAttachement:
                                ob_set_s(annotationObj, L"type", "fileAttachement");
                                break;
                            case ePdfAnnotation_Sound:
                                ob_set_s(annotationObj, L"type", "sound");
                                break;
                            case ePdfAnnotation_Movie:
                                ob_set_s(annotationObj, L"type", "movie");
                                break;
                            case ePdfAnnotation_Widget:
                                ob_set_s(annotationObj, L"type", "widget");
                                break;
                            case ePdfAnnotation_Screen:
                                ob_set_s(annotationObj, L"type", "screen");
                                break;
                            case ePdfAnnotation_PrinterMark:
                                ob_set_s(annotationObj, L"type", "printerMark");
                                break;
                            case ePdfAnnotation_TrapNet:
                                ob_set_s(annotationObj, L"type", "trapNet");
                                break;
                            case ePdfAnnotation_Watermark:
                                ob_set_s(annotationObj, L"type", "watermark");
                                break;
                            case ePdfAnnotation_3D:
                                ob_set_s(annotationObj, L"type", "3D");
                                break;
                            case ePdfAnnotation_RichMedia:
                                ob_set_s(annotationObj, L"type", "richMedia");
                                break;
                            case ePdfAnnotation_WebMedia:
                                ob_set_s(annotationObj, L"type", "webMedia");
                                break;
                            default:
                                ob_set_s(annotationObj, L"type", "unknown");
                                break;
                        }
                  
                    }catch( PdfError & e )
                    {
                        //                        ob_set_n(returnValue, L"error", e.GetError());
                        //                        ob_set_s(returnValue, L"errorDescription", e.what());
                        //                        ob_set_s(returnValue, L"errorMessage", PdfError::ErrorMessage(e.GetError()));
                        
                        e.PrintErrorMsg();
                    }
                    
                    collection_push(annotations, annotationObj);
                    
                }
                
                ob_set_c(pageObj, L"annotation", annotations);

                int fieldCount = page->GetNumFields();
                
                PA_CollectionRef fields = PA_CreateCollection();
                
                for(int f = 0; f < fieldCount; ++f) {
                    
                    PdfField  field = page->GetField(f);
                    EPdfField fieldType = field.GetType();
                    
                    PA_ObjectRef fieldObj = PA_CreateObject();
                    
                    get_field_properties(&field, fieldObj);

                    try{
                        switch (fieldType) {
                            case ePdfField_PushButton:
                            case ePdfField_CheckBox:
                            case ePdfField_RadioButton:
                            {
                                PdfButton pushButton(field);
                                get_button_properties(&pushButton, fieldObj);
                            }
                                break;
                            case ePdfField_TextField:
                            {
                                PdfTextField textField(field);
                                get_textfield_properties(&textField, fieldObj);
                            }
                                break;
                            case ePdfField_ComboBox:
                            case ePdfField_ListBox:
                            {
                                PdfListField listField(field);
                                get_listfield_properties(&listField, fieldObj);
                            }
                                break;
                            case ePdfField_Signature:
                                ob_set_s(fieldObj, L"type", "signature");
                                break;
                            default:
                                ob_set_s(fieldObj, L"type", "unknown");
                                break;
                        }
  
                    }catch( PdfError & e )
                    {
//                        ob_set_n(returnValue, L"error", e.GetError());
//                        ob_set_s(returnValue, L"errorDescription", e.what());
//                        ob_set_s(returnValue, L"errorMessage", PdfError::ErrorMessage(e.GetError()));
                        
                        e.PrintErrorMsg();
                    }
                    
                    collection_push(fields, fieldObj);
  
                }
                
                ob_set_c(pageObj, L"fields", fields);

                collection_push(pagesCol, pageObj);
            }
            
            if(pageCount) {
                PdfAcroForm* pAcroForm = document.GetAcroForm();
                if(!pAcroForm) {
                    
                }
            }
 
        }catch( PdfError & e )
        {
            ob_set_n(returnValue, L"error", e.GetError());
            ob_set_s(returnValue, L"errorDescription", e.what());
            ob_set_s(returnValue, L"errorMessage", PdfError::ErrorMessage(e.GetError()));
            
            e.PrintErrorMsg();
        }
    }
 
#ifndef PODOFO_HAVE_OPENSSL_1_1
        ERR_free_strings();
#endif
    
    ob_set_c(returnValue, L"pages", pagesCol);
    PA_ReturnObject(params, returnValue);
}

#pragma mark debug

static void WriteStringToStream(
                                const PdfString& rsString,
                                std::ostringstream& oss,
                                PdfFont *pFont) {
    
    PdfEncoding* pEncoding = new PdfIdentityEncoding(0, 0xffff, false);
    PdfRefCountedBuffer buffer = pEncoding->ConvertToEncoding( rsString, pFont );
    pdf_long  lLen    = 0;
    char* pBuffer = NULL;
    
    std::auto_ptr<PdfFilter> pFilter = PdfFilterFactory::Create( ePdfFilter_ASCIIHexDecode );
    pFilter->Encode( buffer.GetBuffer(), buffer.GetSize(), &pBuffer, &lLen );
    
    oss << "<";
    oss << std::string( pBuffer, lLen );
    oss << ">";
    
    free( pBuffer );
    delete pEncoding;
}

#pragma mark color

static void set_border_color(PdfField *field, PA_ObjectRef fieldObj) {
    
    if(ob_is_defined(fieldObj, L"borderColor")) {
        PA_ObjectRef color = ob_get_o(fieldObj, L"borderColor");
        if(color) {
            if(
               ob_is_defined(color, L"r")
               && ob_is_defined(color, L"g")
               && ob_is_defined(color, L"b")) {
                field->SetBorderColor(ob_get_n(color, L"r"),
                                      ob_get_n(color, L"g"),
                                      ob_get_n(color, L"b"));
            }else
                if(
                   ob_is_defined(color, L"c")
                   && ob_is_defined(color, L"m")
                   && ob_is_defined(color, L"y")
                   && ob_is_defined(color, L"k")) {
                    field->SetBorderColor(ob_get_n(color, L"c"),
                                          ob_get_n(color, L"m"),
                                          ob_get_n(color, L"y"),
                                          ob_get_n(color, L"k"));
                }
        }else
            if(ob_is_0(fieldObj, L"borderColor")) {
                field->SetBorderColorTransparent();
            }else
            {
                field->SetBorderColor(ob_get_n(fieldObj, L"borderColor"));
            }
    }
}

static void set_background_color(PdfField *field, PA_ObjectRef fieldObj) {
    
    if(ob_is_defined(fieldObj, L"backgroundColor")) {
        PA_ObjectRef color = ob_get_o(fieldObj, L"backgroundColor");
        if(color) {
            if(
               ob_is_defined(color, L"r")
               && ob_is_defined(color, L"g")
               && ob_is_defined(color, L"b")) {
                field->SetBackgroundColor(ob_get_n(color, L"r"),
                                      ob_get_n(color, L"g"),
                                      ob_get_n(color, L"b"));
            }else
                if(
                   ob_is_defined(color, L"c")
                   && ob_is_defined(color, L"m")
                   && ob_is_defined(color, L"y")
                   && ob_is_defined(color, L"k")) {
                    field->SetBackgroundColor(ob_get_n(color, L"c"),
                                          ob_get_n(color, L"m"),
                                          ob_get_n(color, L"y"),
                                          ob_get_n(color, L"k"));
                }
        }else
            if(ob_is_0(fieldObj, L"backgroundColor")) {
                field->SetBackgroundColorTransparent();
            }else
            {
                field->SetBackgroundColor(ob_get_n(fieldObj, L"backgroundColor"));
            }
    }
}

static void set_color(PdfAnnotation *annotation, PA_ObjectRef fieldObj) {
    
    if(ob_is_defined(fieldObj, L"color")) {
        PA_ObjectRef color = ob_get_o(fieldObj, L"color");
        if(color) {
            if(
               ob_is_defined(color, L"r")
               && ob_is_defined(color, L"g")
               && ob_is_defined(color, L"b")) {
                annotation->SetColor(ob_get_n(color, L"r"),
                                      ob_get_n(color, L"g"),
                                      ob_get_n(color, L"b"));
            }else
                if(
                   ob_is_defined(color, L"c")
                   && ob_is_defined(color, L"m")
                   && ob_is_defined(color, L"y")
                   && ob_is_defined(color, L"k")) {
                    annotation->SetColor(ob_get_n(color, L"c"),
                                          ob_get_n(color, L"m"),
                                          ob_get_n(color, L"y"),
                                          ob_get_n(color, L"k"));
                }
        }else
            if(ob_is_0(fieldObj, L"color")) {
                
                annotation->SetColor();
            }else
            {
                annotation->SetColor(ob_get_n(fieldObj, L"color"));
            }
    }
}

static void set_color(PdfPainter *painter, PA_ObjectRef fieldObj) {
    
    if(ob_is_defined(fieldObj, L"color")) {
        PA_ObjectRef color = ob_get_o(fieldObj, L"color");
        if(color) {
            if(
               ob_is_defined(color, L"r")
               && ob_is_defined(color, L"g")
               && ob_is_defined(color, L"b")) {
                painter->SetColor(ob_get_n(color, L"r"),
                                  ob_get_n(color, L"g"),
                                  ob_get_n(color, L"b"));
            }else
                if(
                   ob_is_defined(color, L"c")
                   && ob_is_defined(color, L"m")
                   && ob_is_defined(color, L"y")
                   && ob_is_defined(color, L"k")) {
                    painter->SetColorCMYK(ob_get_n(color, L"c"),
                                          ob_get_n(color, L"m"),
                                          ob_get_n(color, L"y"),
                                          ob_get_n(color, L"k"));
                }
        }else
            if(ob_is_0(fieldObj, L"color")) {
                //no api to make text transparent?
            }else
            {
                painter->SetGray(ob_get_n(fieldObj, L"color"));
            }
    }
}

#pragma mark set prop

static void set_field_properties(PdfField *field, PA_ObjectRef fieldObj) {
    
    if(ob_is_defined(fieldObj, L"isReadOnly")) {
        field->SetReadOnly(ob_get_n(fieldObj, L"isReadOnly"));
    }
    if(ob_is_defined(fieldObj, L"isRequired")) {
        field->SetRequired(ob_get_n(fieldObj, L"isRequired"));
    }
    
    CUTF8String alternateName;
    if(ob_get_s(fieldObj, L"alternateName", &alternateName)) {
        field->SetAlternateName(PdfString((const pdf_utf8 *)alternateName.c_str()));
    }
    
    CUTF8String highlightingMode;
    if(ob_get_s(fieldObj, L"highlightingMode", &highlightingMode)) {
        
        if(highlightingMode.find((const uint8_t *)"none") != CUTF8String::npos) {
            field->SetHighlightingMode(ePdfHighlightingMode_None);
        }
        if(highlightingMode.find((const uint8_t *)"invert") != CUTF8String::npos) {
            field->SetHighlightingMode(ePdfHighlightingMode_Invert);
        }
        if(highlightingMode.find((const uint8_t *)"invertOutline") != CUTF8String::npos) {
            field->SetHighlightingMode(ePdfHighlightingMode_InvertOutline);
        }
        if(highlightingMode.find((const uint8_t *)"push") != CUTF8String::npos) {
            field->SetHighlightingMode(ePdfHighlightingMode_Push);
        }
 
    }
    
}

static void set_checkbox_field_properties(PdfCheckBox *checkboxField, PA_ObjectRef fieldObj) {

    if(ob_is_defined(fieldObj, L"isChecked")) {
        checkboxField->SetChecked(ob_get_b(fieldObj, L"isChecked"));
    }
        
}

static void set_text_properties(PdfAnnotation *annotation, PA_ObjectRef fieldObj, const PdfString &textValue, PdfDocument *document) {
            
    PdfFont *font = NULL;
    
    CUTF8String fontValue;
    if(ob_get_s(fieldObj, L"font", &fontValue)) {
        if(fontValue.length()) {
            font = document->CreateFont((const char *)fontValue.c_str() , new PdfIdentityEncoding(0, 0xffff, true));
        }
    }
        
    if(!font) {
        font = document->CreateFont((const char *)"Arial" , new PdfIdentityEncoding(0, 0xffff, true));
    }
   
    if(font) {
        
        if(ob_is_defined(fieldObj, L"fontSize")) {
            font->SetFontSize(ob_get_n(fieldObj, L"fontSize"));
        }
        
        std::ostringstream  oss;
        oss << "BT" << std::endl << "/" <<   font->GetIdentifier().GetName()
        << " "  <<   font->GetFontSize()
        << " Tf " << std::endl;
        WriteStringToStream(textValue, oss, font);
        oss << "Tj ET" << std::endl;
        
        PdfDictionary resources;
        PdfDictionary fonts;
        fonts.AddKey(font->GetIdentifier().GetName(), font->GetObject()->Reference());
        resources.AddKey(PdfName("Fonts"), fonts);
        annotation->GetObject()->GetDictionary().AddKey(PdfName("DA"), PdfString(oss.str()));
        annotation->GetObject()->GetDictionary().AddKey(PdfName("DR"), resources);
    }

}

static void set_pushbutton_field_properties(PdfPushButton *pushbuttonField, PA_ObjectRef fieldObj, PdfDocument *document) {

    if(ob_is_defined(fieldObj, L"captions")) {
        
        PA_ObjectRef captionsObj = ob_get_o(fieldObj, L"captions");
        if(captionsObj) {
            
            CUTF8String rollover;
            if(ob_get_s(captionsObj, L"rollover", &rollover)) {
                pushbuttonField->SetRolloverCaption(PdfString((const pdf_utf8 *)rollover.c_str()));
            }
            
            CUTF8String normal;
            if(ob_get_s(captionsObj, L"normal", &normal)) {
                PdfString textValue((const pdf_utf8 *)normal.c_str());
                pushbuttonField->SetCaption(textValue);
                set_text_properties(pushbuttonField->GetWidgetAnnotation(), fieldObj, "" /*textValue*/, document);
            }

            CUTF8String alternate;
            if(ob_get_s(captionsObj, L"alternate", &alternate)) {
                pushbuttonField->SetAlternateCaption(PdfString((const pdf_utf8 *)alternate.c_str()));
            }
 
        }

    }
        
}

static void set_list_field_properties(PdfListField *listField, PA_ObjectRef fieldObj, PdfDocument *document) {
    
    if(ob_is_defined(fieldObj, L"isMultiSelect")) {
        listField->SetMultiSelect(ob_get_b(fieldObj, L"isMultiSelect"));
    }
    if(ob_is_defined(fieldObj, L"isCommitOnSelectionChange")) {
        listField->SetCommitOnSelectionChange(ob_get_b(fieldObj, L"isCommitOnSelectionChange"));
    }
    if(ob_is_defined(fieldObj, L"isSorted")) {
        listField->SetSorted(ob_get_b(fieldObj, L"isSorted"));
    }
    if(ob_is_defined(fieldObj, L"isSpellcheckingEnabled")) {
        listField->SetSpellcheckingEnabled(ob_get_b(fieldObj, L"isSpellcheckingEnabled"));
    }
    
    for(int i = listField->GetItemCount(); i ; --i) {
        listField->RemoveItem(0);
    }
    
    PA_CollectionRef items = ob_get_c(fieldObj, L"items");
    if(items) {
        for(PA_long32 i = 0; i < PA_GetCollectionLength(items); ++i) {
            
            PA_Variable v = PA_GetCollectionElement(items, i);
            
            if(PA_GetVariableKind(v) == eVK_Object) {
                PA_ObjectRef itemObj = PA_GetObjectVariable(v);
                if(itemObj) {
                    CUTF8String value;
                    if(ob_get_s(itemObj, L"value", &value)) {
                        CUTF8String displayText;
                        if(ob_get_s(itemObj, L"displayText", &displayText)) {
                            listField->InsertItem((const pdf_utf8*)value.c_str(), (const pdf_utf8*)displayText.c_str());
                        }else{
                            listField->InsertItem((const pdf_utf8*)value.c_str());
                        }
                    }
                }
            }
            
            PA_ClearVariable(&v);
        }
    }
    
    if(ob_is_defined(fieldObj, L"currentItem")) {
        int currentItem = ob_get_n(fieldObj, L"currentItem");
        if(listField->GetItemCount() > currentItem) {
            listField->SetSelectedItem(currentItem);
        }
    }
    
    if(listField->IsComboBox()) {
        if(ob_is_defined(fieldObj, L"isEditable")) {
            ((PdfComboBox *)listField)->SetEditable(ob_get_b(fieldObj, L"isEditable"));
        }
    }
    
    set_text_properties(listField->GetWidgetAnnotation(), fieldObj, "", document);
}

static void set_button_field_properties(PdfButton *buttonField, PA_ObjectRef fieldObj, PdfDocument *document) {

    CUTF8String caption;
    if(ob_get_s(fieldObj, L"caption", &caption)) {
        PdfString textValue((const pdf_utf8 *)caption.c_str());
        buttonField->SetCaption(textValue);
        set_text_properties(buttonField->GetWidgetAnnotation(), fieldObj, "" /*textValue*/, document);
    }
    
    if(buttonField->IsCheckBox()) {
        set_checkbox_field_properties((PdfCheckBox *)buttonField, fieldObj);
    }

    if(buttonField->IsPushButton()) {
        set_pushbutton_field_properties((PdfPushButton *)buttonField, fieldObj, document);
    }

    if(buttonField->IsRadioButton()) {
        //PdfRadioButton not implemented
    }
    
}

static void set_text_field_properties(PdfTextField *textField, PA_ObjectRef fieldObj, PdfDocument *document) {
    
    if(ob_is_defined(fieldObj, L"isPasswordField")) {
        textField->SetPasswordField(ob_get_b(fieldObj, L"isPasswordField"));
    }
    if(ob_is_defined(fieldObj, L"isFileField")) {
        textField->SetFileField(ob_get_b(fieldObj, L"isFileField"));
    }
    if(ob_is_defined(fieldObj, L"isScrollBarsEnabled")) {
        textField->SetScrollBarsEnabled(ob_get_b(fieldObj, L"isScrollBarsEnabled"));
    }
    if(ob_is_defined(fieldObj, L"isRichText")) {
        textField->SetRichText(ob_get_b(fieldObj, L"isRichText"));
    }
    if(ob_is_defined(fieldObj, L"isMultiLine")) {
        textField->SetMultiLine(ob_get_b(fieldObj, L"isMultiLine"));
    }
    if(ob_is_defined(fieldObj, L"isSpellcheckingEnabled")) {
        textField->SetSpellcheckingEnabled(ob_get_n(fieldObj, L"isSpellcheckingEnabled"));
    }

    CUTF8String  u8;
    if(ob_get_s(fieldObj, L"value", &u8)) {
        /*
        PA_long32 dataSize = (u8.length() * sizeof(PA_Unichar) * 2);
        std::vector<char> buf(dataSize);
        
        PA_long32 len = PA_ConvertCharsetToCharset((char *)u8.c_str(),
                                                   u8.length() * sizeof(PA_Unichar),
                                                   eVTC_UTF_8,
                                                   (char *)&buf[0],
                                                   dataSize,
                                                   eVTC_UTF_16_BIGENDIAN);

        PdfString textValue((const pdf_utf16be *)reinterpret_cast<const pdf_utf16be *>(&buf[0]));
    */
        
        PdfString textValue((const pdf_utf8 *)u8.c_str());
        
        set_text_properties(textField->GetWidgetAnnotation(),
                            fieldObj,
                            textValue,
                            document);
        
        textField->SetText(textValue);

    }
    
    if(ob_is_defined(fieldObj, L"maxLen")) {
        textField->SetMaxLen(ob_get_n(fieldObj, L"maxLen"));
    }
    if(ob_is_defined(fieldObj, L"isCombs")) {
        textField->SetCombs(ob_get_b(fieldObj, L"isCombs"));
    }
    
}

static void set_annotation_properties(PdfAnnotation *annotation, PA_ObjectRef annotationObj) {
    
    CUTF8String textValue;
    if(ob_get_s(annotationObj, L"title", &textValue)) {
        annotation->SetTitle((const pdf_utf8 *)textValue.c_str());
    }
    
    if(ob_is_defined(annotationObj, L"open")) {
        annotation->SetOpen(ob_get_b(annotationObj, L"open"));
    }
        
    set_color(annotation, annotationObj);
}

static void set_properties(PdfField *field, PA_ObjectRef fieldObj, PdfDocument *document) {
    
    EPdfField fieldType = field->GetType();

    switch (fieldType) {
        case ePdfField_TextField:
            set_text_field_properties((PdfTextField *)field, fieldObj, document);
            break;

        case ePdfField_CheckBox:
        case ePdfField_RadioButton:
        case ePdfField_PushButton:
            set_button_field_properties((PdfButton *)field, fieldObj, document);
            break;
            
        case ePdfField_ComboBox:
        case ePdfField_ListBox:
            set_list_field_properties((PdfListField *)field, fieldObj, document);
            break;
            
        default:
            break;
    }
    
    set_field_action(field, fieldObj, (PdfMemDocument *)document);
        
    set_color(field->GetWidgetAnnotation(), fieldObj);
    set_border_color(field, fieldObj);
    set_background_color(field, fieldObj);
    
    set_field_properties(field, fieldObj);
}

static void set_page_properties(PdfPage *page, PA_ObjectRef pageObj) {
    
    if(ob_is_defined(pageObj, L"rotation")) {
        int rotation = ob_get_n(pageObj, L"rotation");
        page->SetRotation(rotation);
    }
    if(ob_is_defined(pageObj, L"width")) {
        page->SetPageWidth (convert_to_pdf_unit(pageObj, L"width" ));
    }
    if(ob_is_defined(pageObj, L"height")) {
        page->SetPageHeight(convert_to_pdf_unit(pageObj, L"height"));
    }
}

#pragma mark podofo set

void podofo_set_form(PA_PluginParameters params) {

    PdfError::EnableLogging(false);
    PdfError::EnableDebug(false);
    
    PA_ObjectRef param = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    PA_Picture pdf_in = ob_get_p(param, L"in");
    
    C_BLOB pdf;
    get_picture_data(pdf_in, "pdf", pdf);
    
    CUTF8String param_in, param_out;
    
    if(pdf.getBytesLength()) {
        param_in = (const uint8_t *)"-";
    }else{
        get_param_path(param, L"in" , &param_in);
        get_param_path(param, L"out", &param_out);
    }

    CUTF8String param_password;
    get_param_string(param, L"password", &param_password);
    
#ifdef _WIN32
    CUTF16String w_param_in, w_param_out;
    u8_to_u16(param_in,  w_param_in );
    u8_to_u16(param_out, w_param_out);
    const wchar_t *inputfile  = param_in .length() ? (const wchar_t *)w_param_in .c_str() : NULL;
    const wchar_t *outputfile = param_out.length() ? (const wchar_t *)w_param_out.c_str() : NULL;
#else
    const char *inputfile  = param_in .length() ? (const char *)param_in .c_str() : NULL;
    const char *outputfile = param_out.length() ? (const char *)param_out.c_str() : NULL;
#endif
    
    if(inputfile && param_in.compare(param_out)) {
        
        try
        {
            PdfMemDocument document;
            
            if(param_password.length()) {
                document.SetPassword((const char *)param_password.c_str());
            }
            
            if(pdf.getBytesLength()) {
                document.LoadFromBuffer((const char*)pdf.getBytesPtr(), (long)pdf.getBytesLength(), true);
            }else{
                document.Load(inputfile, true);
            }
            
            PA_CollectionRef pagesCol = ob_get_c(param, L"pages");
            
            if(pagesCol) {
                int pageCount = document.GetPageCount();
                PA_long32 pageLength = PA_GetCollectionLength(pagesCol);
                pageCount = pageCount < pageLength ? pageCount : pageLength;
                
                for(int i = 0; i < pageCount;++i) {
                    
                    PA_ObjectRef pageObj = getObjectInCollection(pagesCol, i);
                    
                    if(pageObj) {
                        
                        PdfPage *page = document.GetPage(i);
                        
                        PdfRect pageRect = page->GetPageSize();
                        double pageHeight = pageRect.GetHeight();
                        double pageWidth  = pageRect.GetWidth() ;
                        
                        set_page_properties(page, pageObj);
                        
                        insert_field(pageObj, pageHeight, page, &document);
                        
                        insert_annotation(pageObj, pageHeight, page, &document);
                        
                        insert_text(pageObj, pageHeight, page, &document);
                        
                    }
                    
                }
            }
            
            if(pdf.getBytesLength()) {
                PdfRefCountedBuffer outputbuffer;
                PdfOutputDevice outputDevice(&outputbuffer);
                document.WriteUpdate(&outputDevice);
                PA_Picture pdf_out = PA_CreatePicture((void *)outputbuffer.GetBuffer(), (PA_long32)outputbuffer.GetSize());
                ob_set_p(returnValue, L"out", pdf_out);
            }else{
                PdfOutputDevice outputDevice(outputfile ? outputfile : inputfile, outputfile != NULL);
                /*
                 :2 false=append, true=truncate
                 if outputfile=null, replace inputfile
                 */
                document.WriteUpdate(&outputDevice, outputfile != NULL);
            }
            
        }catch( PdfError & e )
        {
            ob_set_n(returnValue, L"error", e.GetError());
            ob_set_s(returnValue, L"errorDescription", e.what());
            ob_set_s(returnValue, L"errorMessage", PdfError::ErrorMessage(e.GetError()));
            
            e.PrintErrorMsg();
        }
    }
    
#ifndef PODOFO_HAVE_OPENSSL_1_1
    ERR_free_strings();
#endif
    
    PA_ReturnObject(params, returnValue);
}
